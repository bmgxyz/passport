#!/usr/bin/env python

import os
import sys
import json
import base64
import getpass
import argparse
import subprocess
from pprint import pprint
from Crypto.Hash import SHA256
from Crypto.Cipher import AES

def get_key(passphrase):
    h = SHA256.new()
    h.update(passphrase.encode())
    return h.hexdigest()[:16]

def encrypt_and_write(password_database, filename, passphrase=None):
    # get passphrase from user if one isn't provided
    if passphrase == None:
        passphrase, double_check = "", " "
        while passphrase != double_check:
            if passphrase != "" or double_check != " ":
                print("Passwords do not match")
            passphrase = getpass.getpass("Enter a password: ")
            double_check = getpass.getpass("Enter it again: ")
    # TODO prompt the user to choose between using the same passphrase or a new one
    password_database = json.dumps(password_database)
    # encrypt the database and write it to disk
    key = get_key(passphrase)
    cipher = AES.new(key, AES.MODE_CFB, key)
    password_database = cipher.encrypt(password_database.encode())
    outfile = open(filename, "wb")
    outfile.write(password_database)
    outfile.close()

def read_and_decrypt(filename):
    # get the passphrase from the user
    # TODO implement bad passphrase checking
    password_database = " "
    passphrase = getpass.getpass("Enter database password: ")
    # read and decrypt the password database
    password_database = open(filename, "rb").read()
    key = get_key(passphrase)
    cipher = AES.new(key, AES.MODE_CFB, key)
    password_database = cipher.decrypt(password_database)
    password_database = password_database.decode().strip('"')
    password_database = json.loads(password_database)
    # need to turn the passphrase so we can use it later
    return password_database, passphrase

def create(args):
    blank_database = json.dumps({})
    encrypt_and_write(blank_database, args.database)
    print("New database created")

def list_accounts(args):
    # notify the user if the database is empty
    if password_database == {}:
        print("'"+args.database+"' is empty.")
    # otherwise display all keys in the database in alphabetical order
    else:
        print('\n'.join(sorted(password_database.keys())))

def edit(args):
    # allow the user to update the entry
    if args.account in password_database.keys():
        existing_entry = password_database[args.account]
    else:
        existing_entry = ""
    # TODO generate random name for the temp file
    os.system("echo '"+existing_entry+"' > /tmp/blergh")
    os.system("vi /tmp/blergh")
    password_database[args.account] = open("/tmp/blergh","r").read()
    os.system("rm /tmp/blergh")
    # encrypt the database and write it to disk
    encrypt_and_write(password_database, args.database, passphrase=passphrase)
    print("Updated information for '"+args.account+"'")

def display(args):
    # confirm that the account exists in the database
    if args.account not in password_database.keys():
        print("'"+args.account+"' does not exist in '"+args.database+"'")
    # if it does, then display the password for the particular account specified
    else:
        # TODO add a display timeout?
        # TODO implement a better display method (using ncurses?)
        os.system("echo '"+password_database[args.account]+"' | less")

def remove(args):
    # check to make sure the account exists in the database
    if args.account not in password_database.keys():
        print("'"+args.account+"' does not exist in '"+args.database+"'")
    # otherwise, proceed with confirmation of deletion
    else:
        # confirm that the user really wants to delete the account
        response = ""
        while response not in ["y","Y","n","N"]:
            response = input("Are you sure you want to delete '"+args.account+"'? (y/n) ")
        if response in ["y","Y"]:
            # delete the account
            del password_database[args.account]
            # encrypt and write new password database to disk
            encrypt_and_write(password_database, args.database, passphrase=passphrase)
            print("Removed account '"+args.account+"'")
        else:
            print("Aborted")

# make top-level parser
parser = argparse.ArgumentParser(description="display and manage passwords")
parser.add_argument("database", type=str, help="the database to work on")
subparsers = parser.add_subparsers(dest="choice")
# 'create' subcommand
create_parser = subparsers.add_parser("create", help="make a new blank database")
# 'list' subcommand
list_parser = subparsers.add_parser("list", help="show a list of all entries in the database")
# 'add' subcommand
edit_parser = subparsers.add_parser("edit", help="make a new entry in the selected database")
edit_parser.add_argument("account", type=str, help="friendly unique identifier for the new entry")
# TODO 'search' subcommand
# 'display' subcommand
display_parser = subparsers.add_parser("display", help="display the password associated with a particular account")
display_parser.add_argument("account", type=str, help="the account to display the password for")
# 'modify' subcommand
modify_parser = subparsers.add_parser("modify", help="change the password for an account")
modify_parser.add_argument("account", help="the account to change the password for")
# TODO 'change-master-password' subcommand
# 'remove' subcommand
remove_parser = subparsers.add_parser("remove", help="delete an account from the database")
remove_parser.add_argument("account", type=str, help="name of the account to remove")
# parse all arguments and save namespace object
args = parser.parse_args()

# if we're not creating a new database
if args.choice != "create":
    # read and decrypt the existing database
    global password_database, passphrase
    password_database, passphrase = read_and_decrypt(args.database)

# if the user doesn't choose a subcommand, then display help and exit
if args.choice == None:
    parser.print_help(sys.stderr)
    sys.exit(1)
# otherwise, execute the appropriate subcommand
elif args.choice == "create":
    create(args)
elif args.choice == "list":
    list_accounts(args)
elif args.choice == "edit":
    edit(args)
elif args.choice == "search":
    print("Searching is not yet implemented.")
elif args.choice == "display":
    display(args)
elif args.choice == "remove":
    remove(args)
